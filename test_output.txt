============================= test session starts ==============================
platform darwin -- Python 3.12.7, pytest-7.4.3, pluggy-1.6.0
rootdir: /Users/bwt/demo2
plugins: flask-1.3.0
collected 49 items

simple_test.py ...                                                       [  6%]
tests/test_auth_api.py EEEEEEEEEEEEEEEEEEE                               [ 44%]
tests/test_auth_service.py EEEEEEEEEEEEEEEEE                             [ 79%]
tests/test_user_model.py EEEEEEEEEE                                      [100%]

==================================== ERRORS ====================================
_____________ ERROR at setup of TestAuthAPI.test_register_success ______________

self = <sqlalchemy.engine.base.Connection object at 0x106418980>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067789b0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106793a10>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10670dd60>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067789b0>
cursor = <sqlite3.Cursor object at 0x1067b7540>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106793a10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106419130>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067789b0>
cursor = <sqlite3.Cursor object at 0x1067b7540>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106793a10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

__________ ERROR at setup of TestAuthAPI.test_register_missing_fields __________

self = <sqlalchemy.engine.base.Connection object at 0x106750290>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10673ae10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1067516a0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106751a00>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10673ae10>
cursor = <sqlite3.Cursor object at 0x107422e40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1067516a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_missing_fields>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10673a4e0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10673ae10>
cursor = <sqlite3.Cursor object at 0x107422e40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1067516a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

__________ ERROR at setup of TestAuthAPI.test_register_invalid_email ___________

self = <sqlalchemy.engine.base.Connection object at 0x106750c50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b9ac90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106752210>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106752330>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b9ac90>
cursor = <sqlite3.Cursor object at 0x10677cac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106752210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_invalid_email>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b9a210>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b9ac90>
cursor = <sqlite3.Cursor object at 0x10677cac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106752210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

__________ ERROR at setup of TestAuthAPI.test_register_duplicate_user __________

self = <sqlalchemy.engine.base.Connection object at 0x106b0daf0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067bbe90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b0ffe0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b0ff80>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067bbe90>
cursor = <sqlite3.Cursor object at 0x106b90a40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b0ffe0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_duplicate_user>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106752f60>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067bbe90>
cursor = <sqlite3.Cursor object at 0x106b90a40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b0ffe0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_____________ ERROR at setup of TestAuthAPI.test_register_no_json ______________

self = <sqlalchemy.engine.base.Connection object at 0x106b84d40>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b093a0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b18bc0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b18590>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b093a0>
cursor = <sqlite3.Cursor object at 0x1064052c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b18bc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_no_json>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106751b50>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b093a0>
cursor = <sqlite3.Cursor object at 0x1064052c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b18bc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______________ ERROR at setup of TestAuthAPI.test_login_success _______________

self = <sqlalchemy.engine.base.Connection object at 0x106b843e0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b1b620>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36090>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a36030>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b1b620>
cursor = <sqlite3.Cursor object at 0x1076e37c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_login_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b1b9e0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b1b620>
cursor = <sqlite3.Cursor object at 0x1076e37c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_____________ ERROR at setup of TestAuthAPI.test_login_wrong_email _____________

self = <sqlalchemy.engine.base.Connection object at 0x106a678f0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac1160>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ad86e0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a67fe0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac1160>
cursor = <sqlite3.Cursor object at 0x10775db40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ad86e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_login_wrong_email>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a376e0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac1160>
cursor = <sqlite3.Cursor object at 0x10775db40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ad86e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___________ ERROR at setup of TestAuthAPI.test_login_wrong_password ____________

self = <sqlalchemy.engine.base.Connection object at 0x10641ac60>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adb230>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a66390>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a663f0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adb230>
cursor = <sqlite3.Cursor object at 0x10677f8c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a66390>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_login_wrong_password>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106adb5f0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adb230>
cursor = <sqlite3.Cursor object at 0x10677f8c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a66390>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___________ ERROR at setup of TestAuthAPI.test_login_missing_fields ____________

self = <sqlalchemy.engine.base.Connection object at 0x106a0b5f0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac3b30>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0bdd0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a0bbc0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac3b30>
cursor = <sqlite3.Cursor object at 0x10754fac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0bdd0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_login_missing_fields>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a64770>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac3b30>
cursor = <sqlite3.Cursor object at 0x10754fac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0bdd0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_________ ERROR at setup of TestAuthAPI.test_get_current_user_success __________

self = <sqlalchemy.engine.base.Connection object at 0x106ac4560>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a11b80>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ac51c0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106ac50d0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a11b80>
cursor = <sqlite3.Cursor object at 0x1073e2440>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ac51c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_current_user_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a65460>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a11b80>
cursor = <sqlite3.Cursor object at 0x1073e2440>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ac51c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_________ ERROR at setup of TestAuthAPI.test_get_current_user_no_token _________

self = <sqlalchemy.engine.base.Connection object at 0x106418f20>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac7ce0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107366fc0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x107364920>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac7ce0>
cursor = <sqlite3.Cursor object at 0x10754c340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107366fc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_current_user_no_token>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106ac70b0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac7ce0>
cursor = <sqlite3.Cursor object at 0x10754c340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107366fc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

______ ERROR at setup of TestAuthAPI.test_get_current_user_invalid_token _______

self = <sqlalchemy.engine.base.Connection object at 0x1073501d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d1760>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107350dd0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x107350560>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d1760>
cursor = <sqlite3.Cursor object at 0x106fe8940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107350dd0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_current_user_invalid_token>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107367e00>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d1760>
cursor = <sqlite3.Cursor object at 0x106fe8940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107350dd0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___________ ERROR at setup of TestAuthAPI.test_refresh_token_success ___________

self = <sqlalchemy.engine.base.Connection object at 0x10730b890>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073537a0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10730b110>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10730ac00>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073537a0>
cursor = <sqlite3.Cursor object at 0x1076e0c40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10730b110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_refresh_token_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107352c60>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073537a0>
cursor = <sqlite3.Cursor object at 0x1076e0c40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10730b110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

______ ERROR at setup of TestAuthAPI.test_refresh_token_with_access_token ______

self = <sqlalchemy.engine.base.Connection object at 0x10732bda0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d1250>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073c0a70>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x1073c0980>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d1250>
cursor = <sqlite3.Cursor object at 0x107829340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073c0a70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_refresh_token_with_access_token>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10730ade0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d1250>
cursor = <sqlite3.Cursor object at 0x107829340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073c0a70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

__________ ERROR at setup of TestAuthAPI.test_refresh_token_no_token ___________

self = <sqlalchemy.engine.base.Connection object at 0x107478710>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073c20f0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107479610>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x107478f50>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073c20f0>
cursor = <sqlite3.Cursor object at 0x1078ed140>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107479610>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_refresh_token_no_token>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107309850>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073c20f0>
cursor = <sqlite3.Cursor object at 0x1078ed140>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107479610>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

____________ ERROR at setup of TestAuthAPI.test_api_response_format ____________

self = <sqlalchemy.engine.base.Connection object at 0x1073b08f0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10732a510>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073b0230>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x1073b0500>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10732a510>
cursor = <sqlite3.Cursor object at 0x107b12bc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073b0230>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_api_response_format>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10732bce0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10732a510>
cursor = <sqlite3.Cursor object at 0x107b12bc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073b0230>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_________ ERROR at setup of TestAuthAPI.test_validation_error_details __________

self = <sqlalchemy.engine.base.Connection object at 0x10732ab10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073510d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10732a7b0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10732b5f0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073510d0>
cursor = <sqlite3.Cursor object at 0x1074229c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10732a7b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_validation_error_details>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107350dd0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073510d0>
cursor = <sqlite3.Cursor object at 0x1074229c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10732a7b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______________ ERROR at setup of TestAuthAPI.test_cors_headers ________________

self = <sqlalchemy.engine.base.Connection object at 0x107365700>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d3380>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073643e0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x1073644d0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d3380>
cursor = <sqlite3.Cursor object at 0x106befac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073643e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_cors_headers>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107328a40>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073d3380>
cursor = <sqlite3.Cursor object at 0x106befac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1073643e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___________ ERROR at setup of TestAuthAPI.test_rate_limiting_headers ___________

self = <sqlalchemy.engine.base.Connection object at 0x106a09e80>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a324e0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0ad50>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a0aff0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a324e0>
cursor = <sqlite3.Cursor object at 0x1078ca040>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0ad50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_rate_limiting_headers>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107328140>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a324e0>
cursor = <sqlite3.Cursor object at 0x1078ca040>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0ad50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_________ ERROR at setup of TestAuthService.test_register_user_success _________

self = <sqlalchemy.engine.base.Connection object at 0x106a1ab10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a13950>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a19ac0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a19d60>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a13950>
cursor = <sqlite3.Cursor object at 0x1079dbe40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a19ac0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_user_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a0a480>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a13950>
cursor = <sqlite3.Cursor object at 0x1079dbe40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a19ac0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_____ ERROR at setup of TestAuthService.test_register_user_missing_fields ______

self = <sqlalchemy.engine.base.Connection object at 0x106b11a30>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adbe90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b10860>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b10740>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adbe90>
cursor = <sqlite3.Cursor object at 0x1075aa4c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b10860>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_user_missing_fields>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a67590>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adbe90>
cursor = <sqlite3.Cursor object at 0x1075aa4c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b10860>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_____ ERROR at setup of TestAuthService.test_register_user_duplicate_email _____

self = <sqlalchemy.engine.base.Connection object at 0x106b1b2c0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a353d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b193d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b18e00>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a353d0>
cursor = <sqlite3.Cursor object at 0x1075d3ac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b193d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_user_duplicate_email>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a35e50>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106a353d0>
cursor = <sqlite3.Cursor object at 0x1075d3ac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b193d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___ ERROR at setup of TestAuthService.test_register_user_duplicate_username ____

self = <sqlalchemy.engine.base.Connection object at 0x106b0f2f0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b0c9b0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b181a0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b19550>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b0c9b0>
cursor = <sqlite3.Cursor object at 0x1075abe40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b181a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_user_duplicate_username>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b0dd90>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b0c9b0>
cursor = <sqlite3.Cursor object at 0x1075abe40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b181a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

____ ERROR at setup of TestAuthService.test_register_user_invalid_password _____

self = <sqlalchemy.engine.base.Connection object at 0x106b9b950>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b84950>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b9b980>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b9a600>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b84950>
cursor = <sqlite3.Cursor object at 0x10799f640>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b9b980>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_register_user_invalid_password>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b861b0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b84950>
cursor = <sqlite3.Cursor object at 0x10799f640>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b9b980>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______ ERROR at setup of TestAuthService.test_authenticate_user_success _______

self = <sqlalchemy.engine.base.Connection object at 0x1067799a0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10673a990>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106778d70>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106778140>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10673a990>
cursor = <sqlite3.Cursor object at 0x10790b940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106778d70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_authenticate_user_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b87230>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10673a990>
cursor = <sqlite3.Cursor object at 0x10790b940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106778d70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_____ ERROR at setup of TestAuthService.test_authenticate_user_wrong_email _____

self = <sqlalchemy.engine.base.Connection object at 0x1074c89e0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067903e0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1074c96d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x1074c95e0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067903e0>
cursor = <sqlite3.Cursor object at 0x1075d6ac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1074c96d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_authenticate_user_wrong_email>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106792360>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067903e0>
cursor = <sqlite3.Cursor object at 0x1075d6ac0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x1074c96d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___ ERROR at setup of TestAuthService.test_authenticate_user_wrong_password ____

self = <sqlalchemy.engine.base.Connection object at 0x107472bd0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x107488230>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107473830>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x107473140>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x107488230>
cursor = <sqlite3.Cursor object at 0x1079d0940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107473830>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_authenticate_user_wrong_password>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x1074ca7e0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x107488230>
cursor = <sqlite3.Cursor object at 0x1079d0940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107473830>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

______ ERROR at setup of TestAuthService.test_authenticate_user_inactive _______

self = <sqlalchemy.engine.base.Connection object at 0x107471c70>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1074821e0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107470fe0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x107471a30>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1074821e0>
cursor = <sqlite3.Cursor object at 0x107bbbec0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107470fe0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_authenticate_user_inactive>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107480fe0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1074821e0>
cursor = <sqlite3.Cursor object at 0x107bbbec0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107470fe0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_ ERROR at setup of TestAuthService.test_authenticate_user_missing_credentials _

self = <sqlalchemy.engine.base.Connection object at 0x107466ab0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10748a750>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107467710>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x107467620>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10748a750>
cursor = <sqlite3.Cursor object at 0x107528340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107467710>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_authenticate_user_missing_credentials>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10748b260>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10748a750>
cursor = <sqlite3.Cursor object at 0x107528340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107467710>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

____________ ERROR at setup of TestAuthService.test_get_user_by_id _____________

self = <sqlalchemy.engine.base.Connection object at 0x10673bda0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10749eae0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10673ac00>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10673bc20>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10749eae0>
cursor = <sqlite3.Cursor object at 0x1066ab0c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10673ac00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_user_by_id>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10749d400>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10749eae0>
cursor = <sqlite3.Cursor object at 0x1066ab0c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10673ac00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______ ERROR at setup of TestAuthService.test_get_user_by_id_not_found ________

self = <sqlalchemy.engine.base.Connection object at 0x106a30f50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106bcfe90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a33800>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a32120>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106bcfe90>
cursor = <sqlite3.Cursor object at 0x10754ef40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a33800>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_user_by_id_not_found>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106bcfaa0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106bcfe90>
cursor = <sqlite3.Cursor object at 0x10754ef40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a33800>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

___________ ERROR at setup of TestAuthService.test_get_user_by_email ___________

self = <sqlalchemy.engine.base.Connection object at 0x106b84f20>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10747d7c0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b86f00>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b85b80>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10747d7c0>
cursor = <sqlite3.Cursor object at 0x1079d3d40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b86f00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_user_by_email>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107329220>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10747d7c0>
cursor = <sqlite3.Cursor object at 0x1079d3d40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b86f00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

______ ERROR at setup of TestAuthService.test_get_user_by_email_not_found ______

self = <sqlalchemy.engine.base.Connection object at 0x10747ba70>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10747d6a0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10747aed0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10747a360>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10747d6a0>
cursor = <sqlite3.Cursor object at 0x10754ad40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10747aed0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_get_user_by_email_not_found>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106bcff50>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10747d6a0>
cursor = <sqlite3.Cursor object at 0x10754ad40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10747aed0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

________ ERROR at setup of TestAuthService.test_change_password_success ________

self = <sqlalchemy.engine.base.Connection object at 0x107309460>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073c3ef0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10730aa80>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10730ac30>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073c3ef0>
cursor = <sqlite3.Cursor object at 0x10790bf40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10730aa80>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_change_password_success>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b843e0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073c3ef0>
cursor = <sqlite3.Cursor object at 0x10790bf40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10730aa80>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_____ ERROR at setup of TestAuthService.test_change_password_wrong_current _____

self = <sqlalchemy.engine.base.Connection object at 0x106a1a420>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073b24e0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10735b200>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x10735b0e0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073b24e0>
cursor = <sqlite3.Cursor object at 0x10775d2c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10735b200>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_change_password_wrong_current>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x1073b0050>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1073b24e0>
cursor = <sqlite3.Cursor object at 0x10775d2c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x10735b200>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_ ERROR at setup of TestAuthService.test_change_password_invalid_new_password __

self = <sqlalchemy.engine.base.Connection object at 0x106a08aa0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac5190>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0b800>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a0a0c0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac5190>
cursor = <sqlite3.Cursor object at 0x10799fdc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0b800>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_change_password_invalid_new_password>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10735a390>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac5190>
cursor = <sqlite3.Cursor object at 0x10799fdc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a0b800>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

______________ ERROR at setup of TestUserModel.test_user_creation ______________

self = <sqlalchemy.engine.base.Connection object at 0x106a35b50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac0e30>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36390>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a368a0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac0e30>
cursor = <sqlite3.Cursor object at 0x1075aa640>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36390>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_user_creation>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106ac34a0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac0e30>
cursor = <sqlite3.Cursor object at 0x1075aa640>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36390>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_________ ERROR at setup of TestUserModel.test_email_validation_valid __________

self = <sqlalchemy.engine.base.Connection object at 0x106a34a10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b12d20>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36540>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a35760>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b12d20>
cursor = <sqlite3.Cursor object at 0x106717f40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36540>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_email_validation_valid>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106b11b80>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106b12d20>
cursor = <sqlite3.Cursor object at 0x106717f40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106a36540>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

________ ERROR at setup of TestUserModel.test_email_validation_invalid _________

self = <sqlalchemy.engine.base.Connection object at 0x106b0d9d0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adabd0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b0f4a0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106b0fbf0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adabd0>
cursor = <sqlite3.Cursor object at 0x1078ecfc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b0f4a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_email_validation_invalid>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a66bd0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106adabd0>
cursor = <sqlite3.Cursor object at 0x1078ecfc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106b0f4a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

________ ERROR at setup of TestUserModel.test_username_validation_valid ________

self = <sqlalchemy.engine.base.Connection object at 0x1067917f0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067501d0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106791a00>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x1067914c0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067501d0>
cursor = <sqlite3.Cursor object at 0x10677f940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106791a00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_username_validation_valid>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106a67b00>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1067501d0>
cursor = <sqlite3.Cursor object at 0x10677f940>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106791a00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______ ERROR at setup of TestUserModel.test_username_validation_invalid _______

self = <sqlalchemy.engine.base.Connection object at 0x106c95610>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10677ba10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106c96ea0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106c96d50>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10677ba10>
cursor = <sqlite3.Cursor object at 0x106716140>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106c96ea0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_username_validation_invalid>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x1067795b0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x10677ba10>
cursor = <sqlite3.Cursor object at 0x106716140>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106c96ea0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

________ ERROR at setup of TestUserModel.test_password_validation_valid ________

self = <sqlalchemy.engine.base.Connection object at 0x106ca8dd0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106c5a240>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ca96d0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106a10e30>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106c5a240>
cursor = <sqlite3.Cursor object at 0x1075486c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ca96d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_password_validation_valid>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106c5a660>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106c5a240>
cursor = <sqlite3.Cursor object at 0x1075486c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ca96d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______ ERROR at setup of TestUserModel.test_password_validation_invalid _______

self = <sqlalchemy.engine.base.Connection object at 0x106c2bcb0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106c28470>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106c82f60>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106c83bf0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106c28470>
cursor = <sqlite3.Cursor object at 0x1079377c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106c82f60>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_password_validation_invalid>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106cab710>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106c28470>
cursor = <sqlite3.Cursor object at 0x1079377c0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106c82f60>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

____________ ERROR at setup of TestUserModel.test_password_hashing _____________

self = <sqlalchemy.engine.base.Connection object at 0x106ac2b70>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106751850>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ac0b90>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106ac2810>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106751850>
cursor = <sqlite3.Cursor object at 0x106fe8b40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ac0b90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_password_hashing>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106752720>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106751850>
cursor = <sqlite3.Cursor object at 0x106fe8b40>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106ac0b90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

_______ ERROR at setup of TestUserModel.test_to_dict_excludes_sensitive ________

self = <sqlalchemy.engine.base.Connection object at 0x106bccbf0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac48f0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106bcca40>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x106bcf110>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac48f0>
cursor = <sqlite3.Cursor object at 0x1074fc340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106bcca40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_to_dict_excludes_sensitive>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x106ac75c0>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x106ac48f0>
cursor = <sqlite3.Cursor object at 0x1074fc340>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x106bcca40>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

________________ ERROR at setup of TestUserModel.test_user_repr ________________

self = <sqlalchemy.engine.base.Connection object at 0x107467680>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1074896a0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107467c20>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x1074671d0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1074896a0>
cursor = <sqlite3.Cursor object at 0x107b13dc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107467c20>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: index ix_game_sessions_answer_word already exists

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

request = <SubRequest '_configure_application' for <Function test_user_repr>>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x107489b50>

    @pytest.fixture(autouse=True)
    def _configure_application(request, monkeypatch):
        """Use `pytest.mark.options` decorator to pass options to your application
        factory::
    
            @pytest.mark.options(debug=False)
            def test_something(app):
                assert not app.debug, 'the application works not in debug mode!'
    
        """
        if "app" not in request.fixturenames:
            return
    
>       app = getfixturevalue(request, "app")

venv/lib/python3.12/site-packages/pytest_flask/plugin.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/pytest_flask/pytest_compat.py:3: in getfixturevalue
    return request.getfixturevalue(value)
tests/conftest.py:22: in app
    db.create_all()
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:900: in create_all
    self._call_for_binds(bind_key, "create_all")
venv/lib/python3.12/site-packages/flask_sqlalchemy/extension.py:881: in _call_for_binds
    getattr(metadata, op_name)(bind=engine)
venv/lib/python3.12/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:3243: in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2447: in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:919: in visit_metadata
    self.traverse_single(
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:961: in visit_table
    self.traverse_single(index, create_ok=True)
venv/lib/python3.12/site-packages/sqlalchemy/sql/visitors.py:671: in traverse_single
    return meth(obj, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:998: in visit_index
    CreateIndex(index)._invoke_with(self.connection)
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:315: in _invoke_with
    return bind.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/ddl.py:181: in _execute_on_connection
    return connection._execute_ddl(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1528: in _execute_ddl
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x1074896a0>
cursor = <sqlite3.Cursor object at 0x107b13dc0>
statement = 'CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x107467c20>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) index ix_game_sessions_answer_word already exists
E       [SQL: CREATE INDEX ix_game_sessions_answer_word ON game_sessions (answer_word)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError
---------------------------- Captured stdout setup -----------------------------

Registered routes:
static                         GET,HEAD,OPTIONS     /static/<path:filename>
auth.register                  OPTIONS,POST         /api/auth/register
auth.login                     OPTIONS,POST         /api/auth/login
auth.refresh                   OPTIONS,POST         /api/auth/refresh
auth.get_current_user          GET,HEAD,OPTIONS     /api/auth/me
game.get_daily_puzzle          GET,HEAD,OPTIONS     /api/game/daily/<game_mode>
game.submit_guess              OPTIONS,POST         /api/game/guess
game.get_game_session          GET,HEAD,OPTIONS     /api/game/session/<int:session_id>
game.validate_word             OPTIONS,POST         /api/game/validate
game.get_game_history          GET,HEAD,OPTIONS     /api/game/history/<game_mode>
game.get_game_modes            GET,HEAD,OPTIONS     /api/game/modes
game.get_game_status           GET,HEAD,OPTIONS     /api/game/status/<game_mode>
game.start_new_game            OPTIONS,POST         /api/game/new/<game_mode>
stats.get_user_stats           GET,HEAD,OPTIONS     /api/stats/user/<int:user_id>
stats.get_my_stats             GET,HEAD,OPTIONS     /api/stats/me
stats.get_leaderboard          GET,HEAD,OPTIONS     /api/stats/leaderboard/<game_mode>
stats.get_global_stats         GET,HEAD,OPTIONS     /api/stats/global/<game_mode>
stats.get_user_rank            GET,HEAD,OPTIONS     /api/stats/rank/<game_mode>
stats.get_streak_analysis      GET,HEAD,OPTIONS     /api/stats/streak/<game_mode>
stats.get_stats_summary        GET,HEAD,OPTIONS     /api/stats/summary
health.health_check            GET,HEAD,OPTIONS     /api/health
health.metrics                 GET,HEAD,OPTIONS     /api/metrics
main.index                     GET,HEAD,OPTIONS     /
main.auth_login                GET,HEAD,OPTIONS     /auth/login
main.auth_register             GET,HEAD,OPTIONS     /auth/register
main.game                      GET,HEAD,OPTIONS     /game
main.stats                     GET,HEAD,OPTIONS     /stats
main.history                   GET,HEAD,OPTIONS     /history

=============================== warnings summary ===============================
venv/lib/python3.12/site-packages/pydantic/fields.py:799: 18 warnings
  /Users/bwt/demo2/venv/lib/python3.12/site-packages/pydantic/fields.py:799: PydanticDeprecatedSince20: Using extra keyword arguments on `Field` is deprecated and will be removed. Use `json_schema_extra` instead. (Extra keys: 'env'). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.5/migration/
    warn(

venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:268
  /Users/bwt/demo2/venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:268: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.5/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

simple_test.py::test_user_model
  /Users/bwt/demo2/venv/lib/python3.12/site-packages/_pytest/python.py:198: PytestReturnNotNoneWarning: Expected None, but simple_test.py::test_user_model returned True, which will be an error in a future version of pytest.  Did you mean to use `assert` instead of `return`?
    warnings.warn(

simple_test.py::test_auth_service_logic
  /Users/bwt/demo2/venv/lib/python3.12/site-packages/_pytest/python.py:198: PytestReturnNotNoneWarning: Expected None, but simple_test.py::test_auth_service_logic returned True, which will be an error in a future version of pytest.  Did you mean to use `assert` instead of `return`?
    warnings.warn(

simple_test.py::test_flask_app_creation
  /Users/bwt/demo2/venv/lib/python3.12/site-packages/_pytest/python.py:198: PytestReturnNotNoneWarning: Expected None, but simple_test.py::test_flask_app_creation returned True, which will be an error in a future version of pytest.  Did you mean to use `assert` instead of `return`?
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/test_auth_api.py::TestAuthAPI::test_register_success - sqlalchemy...
ERROR tests/test_auth_api.py::TestAuthAPI::test_register_missing_fields - sql...
ERROR tests/test_auth_api.py::TestAuthAPI::test_register_invalid_email - sqla...
ERROR tests/test_auth_api.py::TestAuthAPI::test_register_duplicate_user - sql...
ERROR tests/test_auth_api.py::TestAuthAPI::test_register_no_json - sqlalchemy...
ERROR tests/test_auth_api.py::TestAuthAPI::test_login_success - sqlalchemy.ex...
ERROR tests/test_auth_api.py::TestAuthAPI::test_login_wrong_email - sqlalchem...
ERROR tests/test_auth_api.py::TestAuthAPI::test_login_wrong_password - sqlalc...
ERROR tests/test_auth_api.py::TestAuthAPI::test_login_missing_fields - sqlalc...
ERROR tests/test_auth_api.py::TestAuthAPI::test_get_current_user_success - sq...
ERROR tests/test_auth_api.py::TestAuthAPI::test_get_current_user_no_token - s...
ERROR tests/test_auth_api.py::TestAuthAPI::test_get_current_user_invalid_token
ERROR tests/test_auth_api.py::TestAuthAPI::test_refresh_token_success - sqlal...
ERROR tests/test_auth_api.py::TestAuthAPI::test_refresh_token_with_access_token
ERROR tests/test_auth_api.py::TestAuthAPI::test_refresh_token_no_token - sqla...
ERROR tests/test_auth_api.py::TestAuthAPI::test_api_response_format - sqlalch...
ERROR tests/test_auth_api.py::TestAuthAPI::test_validation_error_details - sq...
ERROR tests/test_auth_api.py::TestAuthAPI::test_cors_headers - sqlalchemy.exc...
ERROR tests/test_auth_api.py::TestAuthAPI::test_rate_limiting_headers - sqlal...
ERROR tests/test_auth_service.py::TestAuthService::test_register_user_success
ERROR tests/test_auth_service.py::TestAuthService::test_register_user_missing_fields
ERROR tests/test_auth_service.py::TestAuthService::test_register_user_duplicate_email
ERROR tests/test_auth_service.py::TestAuthService::test_register_user_duplicate_username
ERROR tests/test_auth_service.py::TestAuthService::test_register_user_invalid_password
ERROR tests/test_auth_service.py::TestAuthService::test_authenticate_user_success
ERROR tests/test_auth_service.py::TestAuthService::test_authenticate_user_wrong_email
ERROR tests/test_auth_service.py::TestAuthService::test_authenticate_user_wrong_password
ERROR tests/test_auth_service.py::TestAuthService::test_authenticate_user_inactive
ERROR tests/test_auth_service.py::TestAuthService::test_authenticate_user_missing_credentials
ERROR tests/test_auth_service.py::TestAuthService::test_get_user_by_id - sqla...
ERROR tests/test_auth_service.py::TestAuthService::test_get_user_by_id_not_found
ERROR tests/test_auth_service.py::TestAuthService::test_get_user_by_email - s...
ERROR tests/test_auth_service.py::TestAuthService::test_get_user_by_email_not_found
ERROR tests/test_auth_service.py::TestAuthService::test_change_password_success
ERROR tests/test_auth_service.py::TestAuthService::test_change_password_wrong_current
ERROR tests/test_auth_service.py::TestAuthService::test_change_password_invalid_new_password
ERROR tests/test_user_model.py::TestUserModel::test_user_creation - sqlalchem...
ERROR tests/test_user_model.py::TestUserModel::test_email_validation_valid - ...
ERROR tests/test_user_model.py::TestUserModel::test_email_validation_invalid
ERROR tests/test_user_model.py::TestUserModel::test_username_validation_valid
ERROR tests/test_user_model.py::TestUserModel::test_username_validation_invalid
ERROR tests/test_user_model.py::TestUserModel::test_password_validation_valid
ERROR tests/test_user_model.py::TestUserModel::test_password_validation_invalid
ERROR tests/test_user_model.py::TestUserModel::test_password_hashing - sqlalc...
ERROR tests/test_user_model.py::TestUserModel::test_to_dict_excludes_sensitive
ERROR tests/test_user_model.py::TestUserModel::test_user_repr - sqlalchemy.ex...
================== 3 passed, 22 warnings, 46 errors in 6.86s ===================
